{"ast":null,"code":"import React from \"react\";\nvar __jsx = React.createElement;\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { useField } from 'formik';\nimport GenericTextInput from '../GenericTextInput';\nimport CatalogSelect from '../CatalogSelect';\nimport GenericSelect from '../GenericSelect';\nimport GenericSwitch from '../GenericSwitch';\nimport GenericDatePicker from '../GenericDatePicker';\nimport GenericFileLoader from '../GenericFileLoader';\nimport GenericRadioGroup from '../GenericRadioGroup';\n/*\r\n * Esta clase es un auxiliar para manejar formularios. Extiende las funcionalidades\r\n * de la libreria Formik para dar tipado fuerte en base a los modelos usados\r\n * en la aplicacion. Ejemplo de uso:\r\n *\r\n * const { FormTextField } = new GenericForm<ModeloBase>();\r\n *\r\n * y su invocacion:\r\n *\r\n * <FormTextField name=\"campo\" label=\"Mi Campo\" ...>\r\n *\r\n * Por defecto, Typescript validar√° que los valores utilizados en la propiedad name\r\n * sea una propiedad valida de ModeloBase.\r\n *\r\n * -----------------------------MODELOS ANIDADOS------------------------------------\r\n *\r\n *\r\n * Para modelos anidados se puede utilizar la propiedad namespace para indicar el \"path\"\r\n * usando la notacion punto para acceder al modelo. Ejemplo:\r\n *\r\n * class ModeloBase {...};\r\n * class ModeloAnidado {...};\r\n *\r\n * const ModeloBase = {\r\n *      nivel1: {\r\n *          nivel2: {\r\n *              modeloAnidado\r\n *          }\r\n *      }\r\n * }\r\n *\r\n * const { FormTextField } = new GenericForm<ModeloBase>();\r\n *\r\n * y su invocacion:\r\n *\r\n * <FormTextField<ModeloAnidado> namespace=\"nivel.nivel2\" name=\"campo\" label=\"Mi Campo\" ...>\r\n *\r\n * Se especifica ModeloAnidado como tipo de dato para que Typescript nos ayude a validar\r\n * que los valores de la propiedad sean propiedades validas de ModeloAnidado\r\n *\r\n *\r\n */\n\n/*\r\n * NOTA: Se utiliza \"keyof Model\" para decirle a TS que los valores validos de name\r\n * son propedades del objeto Model\r\n */\n\nfunction useNamespacedField(props) {\n  const newName = props.namespace ? `${props.namespace}.${props.name}` : props.name;\n  return useField(_objectSpread(_objectSpread({}, props), {}, {\n    name: newName\n  }));\n}\n\nclass GenericForm {\n  FormTextField(props) {\n    const [field, meta] = useNamespacedField(props);\n    const helperText = meta.error ? meta.error : props.helperText;\n    return __jsx(GenericTextInput, _extends({}, props, field, {\n      error: !!meta.error,\n      helperText: helperText\n    }));\n  }\n\n  FormCatalogSelectField(props) {\n    const [field, meta] = useNamespacedField(props);\n    const helperText = meta.error ? meta.error : props.helperText;\n    return __jsx(CatalogSelect, _extends({}, props, field, {\n      error: !!meta.error,\n      helperText: helperText\n    }));\n  }\n\n  FormSelectField(props) {\n    const [field, meta] = useNamespacedField(props);\n    const helperText = meta.error ? meta.error : props.helperText;\n    return __jsx(GenericSelect, _extends({}, props, field, {\n      error: !!meta.error,\n      helperText: helperText\n    }));\n  }\n\n  FormDatePickerField(props) {\n    const [field, meta] = useNamespacedField(props);\n    const helperText = meta.error ? meta.error : props.helperText;\n    return __jsx(GenericDatePicker, _extends({}, props, field, {\n      error: !!meta.error,\n      helperText: helperText\n    }));\n  }\n\n  FormSwitchField(props) {\n    const [field] = useNamespacedField(_objectSpread(_objectSpread({}, props), {}, {\n      type: 'checkbox'\n    }));\n    return __jsx(GenericSwitch, _extends({}, props, field));\n  }\n\n  FormFileField(props) {\n    const [field, meta] = useNamespacedField(props);\n    const helperText = meta.error ? meta.error : props.helperText;\n    return __jsx(GenericFileLoader, _extends({}, props, field, {\n      error: !!meta.error,\n      helperText: helperText\n    }));\n  }\n\n  FormRadioGroupField(props) {\n    const {\n      children\n    } = props,\n          rest = _objectWithoutProperties(props, [\"children\"]);\n\n    const [field, meta] = useField(rest);\n    const helperText = meta.error ? meta.error : props.helperText;\n    return __jsx(GenericRadioGroup, _extends({}, rest, field, {\n      error: !!meta.error,\n      helperText: helperText\n    }), children);\n  }\n\n}\n\nexport default GenericForm;","map":null,"metadata":{},"sourceType":"module"}