{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport axios from 'axios';\nimport { apiConfig } from '../api.config';\nimport { filterEmptyParameters as removeEemptyParameters } from './utils';\nimport { BatchOperationError, FileUploadError } from './exceptions';\nvar FiduciaDynamicEndpoints;\n\n(function (FiduciaDynamicEndpoints) {\n  FiduciaDynamicEndpoints[\"Get\"] = \"getRef.do\";\n  FiduciaDynamicEndpoints[\"Do\"] = \"doRef.do\";\n  FiduciaDynamicEndpoints[\"Execute\"] = \"executeRef.do\";\n  FiduciaDynamicEndpoints[\"ExecuteJava\"] = \"executeJavaRef.do\";\n  FiduciaDynamicEndpoints[\"UploadFile\"] = \"upload.do\";\n  FiduciaDynamicEndpoints[\"ImprimirReporte\"] = \"imprimirReporte.do\";\n})(FiduciaDynamicEndpoints || (FiduciaDynamicEndpoints = {}));\n\nexport class Api {\n  constructor(config) {\n    _defineProperty(this, \"api\", void 0);\n\n    this.api = axios.create(_objectSpread(_objectSpread({}, apiConfig), config)); // this middleware is been called right before the http request is made.\n\n    this.api.interceptors.request.use(param => _objectSpread({}, param)); // this middleware is been called right before the response is get it by the method that triggers the request\n\n    this.api.interceptors.response.use(param => _objectSpread({}, param));\n  }\n\n  getUri(config) {\n    return this.api.getUri(config);\n  }\n\n  request(config) {\n    return this.api.request(config);\n  }\n\n  get(url, config) {\n    return this.api.get(url, config);\n  }\n\n  delete(url, config) {\n    return this.api.delete(url, config);\n  }\n\n  head(url, config) {\n    return this.api.head(url, config);\n  }\n\n  post(url, data, config) {\n    return this.api.post(url, data, config);\n  }\n\n  put(url, data, config) {\n    return this.api.put(url, data, config);\n  }\n\n  patch(url, data, config) {\n    return this.api.patch(url, data, config);\n  }\n\n  async sendDynamicRequest(endpoint, refName, params, filterEmptyParameters = true) {\n    let filteredParams = filterEmptyParameters ? removeEemptyParameters(params) : params;\n    Object.assign(filteredParams, {\n      id: refName\n    });\n    return this.get(endpoint, {\n      params: {\n        json: JSON.stringify(filteredParams)\n      }\n    }).then(response => {\n      if (response === null) {\n        throw new Error('Ocurrio un error al procesar el request');\n      } else {\n        return response;\n      }\n    });\n  }\n\n  async downloadDynamicFile(filename, endpoint, refName, params, filterEmptyParameters = true) {\n    let filteredParams = filterEmptyParameters ? removeEemptyParameters(params) : params;\n    Object.assign(filteredParams, {\n      id: refName\n    });\n    return this.get(endpoint, {\n      params: {\n        json: JSON.stringify(filteredParams)\n      },\n      responseType: 'blob'\n    }).then(response => {\n      if (response === null) {\n        throw new Error('Ocurrio un error al procesar el request');\n      } else {\n        this.downloadFile(response.data, filename);\n      }\n    });\n  }\n\n  downloadFile(file, filename) {\n    const anchor = window.document.createElement('a');\n    anchor.href = URL.createObjectURL(file);\n    anchor.download = filename;\n    document.body.appendChild(anchor);\n    anchor.click();\n    document.body.removeChild(anchor); // Removes browser reference to the file\n\n    setTimeout(function () {\n      URL.revokeObjectURL(anchor.href);\n    }, 250);\n  }\n\n  async getRef(refName, params, transformer) {\n    return this.sendDynamicRequest(FiduciaDynamicEndpoints.Get, refName, params).then(response => {\n      const data = response.data;\n      return data.map(transformer);\n    });\n  }\n\n  async executeRef(refName, data) {\n    return this.sendDynamicRequest(FiduciaDynamicEndpoints.Execute, refName, data, false).then(response => {\n      return response.data.result;\n    });\n  }\n\n  async doRef(refName, data) {\n    return this.sendDynamicRequest(FiduciaDynamicEndpoints.Execute, refName, data, false).then(response => {\n      return response.data.result;\n    });\n  }\n\n  async downloadDynamicReport(filename, refName, data) {\n    this.downloadDynamicFile(filename, FiduciaDynamicEndpoints.ImprimirReporte, refName, data, true);\n  }\n\n  async executeRemoteMethod(refName, data) {\n    return this.sendDynamicRequest(FiduciaDynamicEndpoints.ExecuteJava, refName, data, false).then(response => {\n      return response.data.result;\n    });\n  }\n\n  handleBatchOperation(promises, models) {\n    return Promise.allSettled(promises).then(results => {\n      let failedModels = [];\n      results.forEach((result, index) => {\n        if (result.status === 'rejected') {\n          failedModels.push(models[index]);\n        }\n      });\n\n      if (failedModels.length) {\n        const errorMessage = `Operacion incompleta. Ocurrio un error al eliminar ${failedModels.length} de ${models.length} registro(s).`;\n        throw new BatchOperationError(failedModels, errorMessage);\n      }\n    });\n  }\n\n  async getAsyncOperationStatus(transactionId) {\n    return this.sendDynamicRequest(FiduciaDynamicEndpoints.Get, 'consultaEstatusTransaccionAsync', {\n      transactionId: transactionId\n    }).then(response => {\n      const data = response.data;\n\n      if (!data || !data.length) {\n        throw new Error('Ocurrio un error inesperado');\n      }\n\n      const result = data[0];\n      const transactionCompleted = Boolean(result.transactionCompleted);\n      const transactionError = result.transactionError;\n\n      if (!transactionCompleted) {\n        throw new Error(transactionError);\n      }\n    });\n  }\n\n  uploadFiles(url, files = [], params = {}) {\n    var formData = new FormData();\n    files.forEach((file, index) => {\n      formData.append(`file_${index + 1}`, file);\n    });\n    Object.entries(params).forEach(([key, value]) => {\n      formData.append(key, value);\n    });\n    return this.api.post(url, formData, {\n      headers: {\n        'Content-Type': 'multipart/form-data'\n      }\n    });\n  }\n\n  async uploadFilesWithProcessor(files = [], processorName, otherParams = {}) {\n    // TODO: Cambiar por UUID\n    const transactionId = `${Math.floor(Math.random() * 1000000)}`;\n\n    try {\n      await this.uploadFiles(FiduciaDynamicEndpoints.UploadFile, files, _objectSpread(_objectSpread({}, otherParams), {}, {\n        numTransaccion: transactionId,\n        processor: processorName\n      }));\n    } catch (error) {\n      console.log('error al subir archivo', error);\n      throw new FileUploadError();\n    } finally {\n      await this.getAsyncOperationStatus(transactionId);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}